package  {	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.geom.Point;	import flash.display.SimpleButton;	import flash.events.MouseEvent;	import flash.net.FileReference;	import flash.geom.Rectangle;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.geom.Matrix;	import flash.utils.ByteArray;		import com.greensock.TweenLite;	import com.greensock.easing.Strong;		import com.adobe.images.JPGEncoder;	import com.adobe.images.PNGEncoder;	import flash.display.DisplayObject;	public class DemonBoard {		// disable if you want to save as JPG		private static const SAVE_AS_PNG : Boolean = true;		private static const JPG_QUALITY : int = 80;				// I had to hard code the mask as I couldn't get the actual coordinates from 		// the drawing area for some reason..		//		// set MASKING_ON to false if you want to disable masking		private static const MASKING_ON : Boolean = true;		private static const MASK_X : int = 1135;		private static const MASK_Y:  int = 138;				private static const ANIMATE_MASK : Boolean = false;		private static const ANIMATE_TIME : Number = 0.65;		private static const ANIMATE_DELAY : Number = 0.5;				private static const CLEAR_TIME : Number = 0.5;		private static const CLEAR_DELAY : Number = 0.1;				//private var _board : MovieClip;		private var _boardSprite : Sprite;		private var _mask : Sprite;				private var _saveButton : SimpleButton;		private var _clearButton : SimpleButton;		private var _menu : PartSelectionMenu;		private var _isClearing : Boolean = false;		private var _numChildrenToClear : int = 0;				public function DemonBoard(board : MovieClip, saveButton : SimpleButton, clearButton : SimpleButton, menu : PartSelectionMenu) {						// create sprite in place of dd_area (easier to render to image)			_boardSprite = new Sprite();			_boardSprite.graphics.beginFill(0xFFFFFF);			_boardSprite.graphics.drawRect(0, 0, board.width, board.height);			_boardSprite.graphics.endFill();			_boardSprite.x = MASK_X;			_boardSprite.y = MASK_Y;						board.parent.addChild(_boardSprite);			board.parent.removeChild(board);						board = null;						//_board = board;			_saveButton = saveButton;			_clearButton = clearButton;			_menu = menu;						Initialize();		}				private function Initialize() : void		{			_saveButton.addEventListener(MouseEvent.MOUSE_DOWN, SaveDemonToImageFile);			_clearButton.addEventListener(MouseEvent.MOUSE_DOWN, ClearDemonBoard);						if (MASKING_ON) {				_mask = new Sprite();								_mask.graphics.beginFill(0xFF0000);				_mask.graphics.drawRect(0, 0, _boardSprite.width, _boardSprite.height);				_mask.graphics.endFill();								var globalPos : Point = _boardSprite.localToGlobal(new Point(_boardSprite.x, _boardSprite.y));				_mask.x = MASK_X;				_mask.y = MASK_Y;								_boardSprite.stage.addChild(_mask);								_boardSprite.mask = _mask;								if (ANIMATE_MASK) {					_mask.y = 2000;										TweenLite.to(_mask, ANIMATE_TIME, {y: MASK_Y, delay: ANIMATE_DELAY, ease: Strong.easeOut });				}			}		}				private function SaveDemonToImageFile(e : MouseEvent) : void {			var fileReference : FileReference = new FileReference();						var bitmapData = new BitmapData( _boardSprite.mask.width, _boardSprite.mask.height ); // creates the bitmap of the mask's size			var m:Matrix = new Matrix();			m.translate( -_boardSprite.x, -_boardSprite.y ); // Create the matrix used to translate the positions of the source image.						bitmapData.draw(_boardSprite.stage, m, null, null, null, true); // draw the bitmapdata considering the offset of the mask 			var imgByteData : ByteArray;			var filename : String;						if (SAVE_AS_PNG) {				imgByteData = PNGEncoder.encode(bitmapData);				filename = "Demon.png";							} else {				var jpgEncoder:JPGEncoder = new JPGEncoder(JPG_QUALITY);           				imgByteData = jpgEncoder.encode(bitmapData);				filename = "Demon.jpg";			}						fileReference.save(imgByteData, filename); 		}				private function ClearDemonBoard(e : MouseEvent) : void {			var numChildren : int = _boardSprite.numChildren;						for (var index : int = 0; index < numChildren; ++index) {				var demonPart : DisplayObject  = _boardSprite.getChildAt(index);								if (demonPart != _mask) {					TweenLite.to(demonPart, CLEAR_TIME, { alpha: 0, delay: index * CLEAR_DELAY, onComplete:OnDemonPartFaded, onCompleteParams: [demonPart] });									++_numChildrenToClear;				}			}		}				private function OnDemonPartFaded(object : MovieClip) : void {			object.parent.removeChild(object);						var originalParent : Sprite = DraggableDemonPart.GetDraggableDemonPartOriginalParentFromInstance(object);			var originalPosition : Point = DraggableDemonPart.GetDraggableDemonPartOriginalPositionFromIntance(object);						originalParent.addChild(object);			object.x = originalPosition.x;			object.y = originalPosition.y;						--_numChildrenToClear;						if (_numChildrenToClear == 0) {				_isClearing = false;								_menu.Reset();			}		}				public function get boardSprite() : Sprite {			return _boardSprite;		}	}	}